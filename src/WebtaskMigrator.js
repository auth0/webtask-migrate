'use strict';

const Assert = require('assert');
const _ = require('lodash');

const TokenStore = require('./TokenStore');
const Deployment = require('./Deployment');
const Webtask = require('./Webtask');
const WebtaskAnalyzer = require('./WebtaskAnalyzer');

const maxReportRetry = 10;
const reportWebtaskName = 'webtaskio-migration-report';
const reportWebtaskCode = `
//
// Webtask.io Migration Report Webtask
//

//
// This webtask was generated by the migration process.
// If you browse to the URL and execute the webtask it will
// return back an HTML report of the migration.
//
// You can safely delete this webtask once you no longer
// need the webtask migration report data
//
const https = require('https');

module.exports = (ctx, req, res) => {
    ctx.storage.get((error, data) => {
        if (error) {
            data = { results: [] };
        }

        if (req.url === '/${reportWebtaskName}/export') {
            res.writeHead(200, {
                 'Content-disposition': 'attachment; filename= webtaskio-migration-report.json',
                 'Content-type': 'application/json'
            });
            res.write(JSON.stringify(data, null, 2));
            res.end()
        }

        const proxyReq = https.request({
            hostname: 'webtask-migrate.sandbox.auth0-extend.com',
            headers: {
                'Content-Type': 'application/json'
              },
            path: req.url,
            method: 'post',
        },  proxyRes => {
                var proxyData = '';
                proxyRes.setEncoding('utf8');
                proxyRes.on('data', chunk => proxyData += chunk.toString());
                proxyRes.on('end', () => {
                    res.writeHead(proxyRes.statusCode, proxyRes.headers);
                    res.end(proxyData);
                });
            }
        );

        proxyReq.write(JSON.stringify(data));
        proxyReq.end();
    });
};`;

const Warning = {
    unsupportedModule: 'unsupportedModule',
    provisioningModule: 'provisioningModule',
};

const Response = {
    alreadyExists: 'alreadyExists',
    downloadFailed: 'downloadFailed',
    uploadFailed: 'uploadFailed',
    analysisFailed: 'analysisFailed',
    provisionFailed: 'provisionFailed',
    migrating: 'migrating',
    migrated: 'migrated',
    withWarnings: 'withWarnings',
};

const responseMessages = {
    alreadyExists: 'A webtask with the same name already exists.',
    downloadFailed: 'Unable to download the webtask.',
    uploadFailed: 'Unable to upload the webtask.',
    analysisFailed: 'Unable to run analysis on the webtask.',
    provisionFailed: 'Unable to provision the required modules',
    migrating: 'The webtask is currently being migrated',
    migrated: 'The webtask was successfully migrated',
    withWarnings: 'The webtask was migrated with warnings',
};

const responseStatus = {
    alreadyExists: 'failed',
    downloadFailed: 'failed',
    uploadFailed: 'failed',
    analysisFailed: 'failed',
    provisionFailed: 'failed',
    migrating: 'migrating',
    migrated: 'migrated',
    withWarnings: 'migrated',
};

function createResponse(responseType, warnings) {
    const message = responseMessages[responseType];
    const status = responseStatus[responseType];
    const runAt = new Date().toISOString();
    const autoMigrated = false;
    const url = '';

    return { message, status, runAt, autoMigrated, url, warnings };
}

function createWarning(warningType, aModule) {
    let message = '';

    if (warningType === Warning.unsupportedModule) {
        message = [
            `The module '${aModule.name}@${
                aModule.version
            }' is not supported on the new deployment.`,
            'Consider using a newer version of the module.',
        ].join(' ');
    }
    if (warningType === Warning.provisioningModule) {
        message = [
            `The module '${aModule.name}@${
                aModule.version
            }' is currently being provisioned.`,
            'The webtask may fail to excute properly until',
            'the module has finished provisioning.',
        ].join(' ');
    }

    return {
        warningType,
        codeType: '',
        value: `${result.name}@${result.version}`,
        line: 0,
        column: 0,
        message,
    };
}

async function download(migrator, tenantName, webtaskName) {
    const deployment = migrator._fromDeployment;

    const downloadOptions = {
        includeCron: migrator._includeCron,
        includeStorage: migrator._includeStorage,
        includeSecrets: migrator._includeSecrets,
    };

    try {
        return await deployment.downloadWebtask(
            tenantName,
            webtaskName,
            downloadOptions
        );
    } catch (error) {
        // do nothing
    }

    return null;
}

async function checkExists(migrator, tenantName, webtaskName) {
    if (migrator._dryRun || migrator._replaceIfExists) {
        return null;
    }

    const deployment = migrator._toDeployment;
    try {
        const exists = await deployment.downloadWebtask(
            tenantName,
            webtaskName
        );
        return exists ? createResponse(Response.alreadyExists) : null;
    } catch (error) {
        // do nothing
    }

    return null;
}

async function analyze(migrator, tenantName, webtaskName, webtask) {
    const analyzer = migrator._webtaskAnalyzer;
    try {
        return await analyzer.analyze(tenantName, webtaskName, webtask);
    } catch (error) {
        // do nothing
    }

    return null;
}

async function provision(migrator, tenantName, webtask, analysis) {
    const deployment = migrator._toDeployment;

    try {
        const dependencies = webtask.getDependencies();
        const results = await deployment.provisionModules(
            dependencies,
            tenantName
        );

        for (const result of results) {
            let warningType;

            if (result.state === 'failed') {
                warningType = Warning.unsupportedModule;
            } else if (result.state === 'queued') {
                if (migrator._warnOnProvisioningModules) {
                    warningType = Warning.provisioningModule;
                } else {
                    return createResponse(Response.migrating);
                }
            }

            if (warningType) {
                const warning = createWarning(
                    Warning.provisioningModule,
                    result
                );
                analysis.warnings.push(warning);
            }
        }
    } catch (error) {
        return createResponse(Response.provisionFailed);
    }

    return null;
}

async function upload(migrator, tenantName, webtaskName, webtask) {
    if (migrator._dryRun) {
        return null;
    }

    const deployment = migrator._toDeployment;
    try {
        const options = {
            ignoreClaims: migrator._ignoreClaims,
            overwriteStorage: true,
        };
        await deployment.uploadWebtask(
            tenantName,
            webtaskName,
            webtask,
            options
        );
    } catch (error) {
        return createResponse(Response.uploadFailed);
    }

    return null;
}

async function report(migrator, tenantName, webtaskName, results) {
    const deployment = migrator._toDeployment;

    let reportWebtask = await deployment.downloadWebtask(
        tenantName,
        reportWebtaskName,
        { includeStorage: true }
    );

    if (!reportWebtask) {
        reportWebtask = new Webtask(reportWebtaskCode);
    }

    const data = reportWebtask.getStorageData();
    const report = data ? JSON.parse(data) : { results: [] };
    const allResults = report.results;
    const existing = _.remove(allResults, entry => entry.name === webtaskName);

    if (existing.length) {
        if (results.message === responseMessages.alreadyExists) {
            return;
        }
    }

    const clonedResults = _.cloneDeep(results);
    clonedResults.name = webtaskName;
    allResults.push(clonedResults);
    reportWebtask.setStorageData(JSON.stringify(report));

    await deployment.uploadWebtask(
        tenantName,
        reportWebtaskName,
        reportWebtask,
        { overwriteStorage: false }
    );

    const deploymentUrl = migrator._toDeployment.getDeploymentUrl();
    const domain = deploymentUrl.replace('https://', '');
    const safeTenant = encodeURIComponent(tenantName);
    const safeWebtask = encodeURIComponent(reportWebtaskName);
    results.url = `https://${safeTenant}.${domain}/${safeWebtask}`;
}

async function migrateWebtask(migrator, tenantName, webtaskName) {
    let response;

    const webtask = await download(migrator, tenantName, webtaskName);
    if (!webtask) {
        return createResponse(Response.downloadFailed);
    }

    response = await checkExists(migrator, tenantName, webtaskName);
    if (response) {
        return response;
    }

    const analysis = await analyze(migrator, tenantName, webtaskName, webtask);
    if (!analysis) {
        return createResponse(Response.analysisFailed);
    }

    webtask.addDependencies(analysis.dependencies);

    response = await provision(migrator, tenantName, webtask, analysis);
    if (response) {
        return response;
    }

    response = await upload(migrator, tenantName, webtaskName, webtask);
    if (response) {
        return response;
    }

    return analysis.warnings.length
        ? createResponse(Response.withWarnings, analysis.warnings)
        : createResponse(Response.migrated);
}

async function generateReport(migrator, tenantName, webtaskName, results) {
    if (migrator._generateReport) {
        for (let attempt = 0; attempt < maxReportRetry; attempt++) {
            try {
                await report(migrator, tenantName, webtaskName, results);
                break;
            } catch (error) {
                // do nothing
            }
        }
    }
}

class WebtaskMigrator {
    constructor(fromDeployment, toDeployment, options) {
        Assert.ok(
            fromDeployment instanceof Deployment,
            'fromDeployment(Deployment) required'
        );
        Assert.ok(
            toDeployment instanceof Deployment,
            'toDeployment(Deployment) required'
        );
        options = options || {};
        Assert.ok(_.isObject(options), 'options(object) invalid type');

        this._fromDeployment = fromDeployment;
        this._toDeployment = toDeployment;

        this._replaceIfExists = options.replaceIfExists || false;
        this._dryRun = options.dryRun === false ? false : true;
        this._includeCron = options.includeCron || false;
        this._includeStorage = options.includeStorage || false;
        this._includeSecrets = options.includeSecrets || false;
        this._ignoreClaims = options.ignoreClaims || false;
        this._warnOnProvisioningModules =
            options.warnOnProvisioningModules || false;
        this._generateReport = options.generateReport || false;
        this._autoMigrated = options.autoMigrated || false;

        this._webtaskAnalyzer = new WebtaskAnalyzer(this._fromDeployment, {
            warnOnClaims: this._ignoreClaims,
        });
    }

    async migrate(tenantName, webtaskName) {
        Assert.ok(_.isString(tenantName), 'tenantName(string) required');
        Assert.ok(_.isString(webtaskName), 'webtaskName(string) required');

        const results = await migrateWebtask(this, tenantName, webtaskName);
        results.autoMigrated = this._autoMigrated;

        generateReport(this, tenantName, webtaskName, results);

        return results;
    }
}

module.exports = WebtaskMigrator;
